library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult is
   port (a, b: in std_logic_vector(3 downto 0);
          start: in std_logic;
          p: out std_logic_vector(7 downto 0);
         clk, reset : in std_logic);
end entity;


-- a direct implementatio of the count down timer...
-- may not be the most efficient...
architecture Behave of mult is
   -- Q
   type FsmState is (IDLE, WORKS, DONESTATE);
   signal fsm_state: FsmState;

   -- R
   signal counter: std_logic_vector(1 downto 0);
   signal R: std_logic_vector(7 downto 0);
   signal T:  std_logic_vector(2 downto 0);

   -- useful constant.
   constant Z2: std_logic_vector(1 downto 0) := (others => '0');
begin

  process(clk, reset, fsm_state, counter, start, R, T)
    variable next_counter_var: std_logic_vector(1 downto 0);
    variable next_fsm_state_var: FsmState;
    variable y: std_logic_vector(7 downto 0);
    variable done_var: std_logic;
  begin
    -- default values.
    counter := "00";
    next_counter_var := counter;
    next_fsm_state_var := fsm_state;
    y := '00000000';
    Done_var := '0';

    -- delta, mu, lambda functions.
    case fsm_state is
       when IDLE => 
            if (Start = '1') then
                  next_fsm_state_var := WORKS;
                  R(7) <= 0;
                  if (b(0) = '0') then
			R(6 downto 3) <= "0000";
                  else
			R(6 downto 3) <= a;
		  end if;
                  R(2 downto 0) <= "000";
                  T <= b(3 downto 1);
                  next_counter_var := "00";
  	    else
		 next_fsm_state_var := IDLE;
            end if;
       when WORKS => 
            if (counter = "11" ) then
                  next_fsm_state_var := DONESTATE;
                  y := R(7 downto 0);
	    else
                next_fsm_state_var := WORKS;
                if (T(0) = '0') then
			R(7 downto 3) <= R(7 downto 4);
                  else
			R(7 downto 3) <= std_logic_vector(unsigned(R(7 downto 4)) + unsigned(a));
		  end if;
		R(7 downto 3) <= (R(7 downto 4) + (T(0) ? a: 0));
		R(2 downto 0) <= R(3 downto 1);
                T <= (T>>1);
 		next_counter_var := std_logic_vector(unsigned(counter) + 1);
            end if;
       when DONESTATE => 
            Done_var := '1';
            if (Start = '1') then
                  next_fsm_state_var := WORKS;
                  
            end if;
    end case;

    -- Done is an output of the FSM
    Done <= Done_var;
    p <= y;
    -- update state, registers.
    if(clk'event and clk='1') then
        if(reset = '1') then
           fsm_state <= IDLE;
        else
           fsm_state <= next_fsm_state_var;       
	   counter <= next_counter_var;
        end if;
    end if;
  end process;

end Behave;

